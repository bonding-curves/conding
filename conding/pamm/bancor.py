# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/pamm/01_bancor.ipynb.

# %% auto 0
__all__ = ['BondingCurve']

# %% ../../nbs/pamm/01_bancor.ipynb 3
import param as pm
import panel as pn
import pandas as pd
import numpy as np
import hvplot.pandas
import holoviews as hv

# %% ../../nbs/pamm/01_bancor.ipynb 4
class BondingCurve(pm.Parameterized):
    supply = pm.Number(80, softbounds=(1, 100), bounds=(1, None), step=1)
    price = pm.Number(2, softbounds=(0.01, 5), bounds=(0.01, None),  step=0.01)
    reserve_balance = pm.Number(40, softbounds=(10, 500), bounds=(1, None), step=1)
    marketcap = pm.Number(160, constant=True)
    reserve_ratio = pm.Number(0.25, constant=True, step=0.01)
    n = pm.Number(constant=True)
    m = pm.Number(constant=True)
    
    mint_amount = pm.Number(1, step=0.1)
    deposit = pm.Number(constant=True)
    mint_price = pm.Number(constant=True)
    new_price = pm.Number(constant=True)
    
    mint = pm.Action(lambda self: self._mint())
    
    def __init__(self, **params):
        super().__init__(**params)
        self.update()
    
    @pm.depends('reserve_balance', 'supply', 'price', 'mint_amount', watch=True)
    def update(self):
        with pm.edit_constant(self):
            self.marketcap = self.price * self.supply
            self.reserve_ratio = self.reserve_balance / self.marketcap
            self.param['mint_amount'].bounds = [-self.supply+1, None]
            self.n = ((1 / self.reserve_ratio) - 1)
            self.m = self.price / self.supply ** self.n
            if self.mint_amount == 0:
                self.deposit = 0
                self.mint_price = self.price
                self.new_price = self.price
            else:
                self.deposit = self.get_balance_deposit(self.mint_amount)
                self.mint_price = self.deposit / self.mint_amount
                self.new_price = self.get_price(self.supply+self.mint_amount)

    def get_price(self, supply):
        price = self.m * supply ** self.n
        return price
    
    def get_marketcap(self, supply):
        marketcap = self.get_price(supply) * supply
        return marketcap
    
    def get_reserve_balance(self, supply):
        reserve_balance = self.reserve_ratio * self.get_marketcap(supply)
        return reserve_balance
    
    # How much balance to deposit given a mint amount
    def get_balance_deposit(self, mint_amount):
        balance_deposit = self.get_reserve_balance(self.supply+mint_amount) - self.reserve_balance
        return balance_deposit
            
    # How much balance to return given a burn amount
    def get_balance_return(self, burn_amount):
        balance_return = self.reserve_balance - self.get_reserve_balance(self.supply-burn_amount)
        return balance_return
        
    # How much supply minted given a balance deposit
    def get_mint_amount(self, balance_deposit):
        mint_amount = self.supply * ((balance_deposit / self.get_reserve_balance(self.supply) + 1) ** (self.reserve_ratio) - 1)
        return mint_amount
    
    # How much supply to burn given a desired balance return
    def get_burn_amount(self, balance_return):
        return -self.get_mint_amount(-balance_return)
    
    def _mint(self):
        with pm.parameterized.discard_events(self):
            self.supply = self.supply + self.mint_amount
            self.reserve_balance = self.reserve_balance + self.deposit
            self.price = self.new_price
            self.mint_amount = 0
        self.param.trigger('supply', 'reserve_balance', 'price', 'mint_amount')
        
    def price_over_supply_curve(self):
        supply = np.linspace(*self.param['supply'].softbounds, num=1000)
        prices = self.get_price(supply)
        balance_slope = np.where(supply <= self.supply, prices, 0)
        marketcap_slope = np.where(supply <= self.supply, self.price, 0)
        future_supply = self.supply + self.mint_amount
        if future_supply > self.supply:
            balance_deposit = np.where((self.supply <= supply) & (supply <= future_supply), prices, 0)
        else:
            balance_deposit = np.where((future_supply <= supply) & (supply <= self.supply), prices, 0)
            
        new_price = np.where(supply <= future_supply, self.get_price(future_supply), 0)
        
        df = pd.DataFrame({
            'Supply': supply, 
            'Price': prices, 
            'Reserve Balance': balance_slope,
            'Marketcap': marketcap_slope,
            'Minting Deposit': balance_deposit,
            'New Price': new_price,
        })
        return df
    
    def view_price_over_supply_curve(self):
        price_over_supply_curve = self.price_over_supply_curve()
        price_curve = price_over_supply_curve.hvplot.line(x='Supply',y='Price')
        price_curve.opts( 
            color='purple', 
        )
        new_price = price_over_supply_curve.hvplot.area(x='Supply',y='New Price', y2='Marketcap')
        new_price.opts( 
            color='orange', 
            alpha=0.4,
        )
        balance_integral = price_over_supply_curve.hvplot.area(
            x='Supply', 
            y=['Marketcap', 'Reserve Balance', 'Minting Deposit'], 
            color=['green', 'blue', 'red'],
            alpha=0.4,
            stacked=False,
        )

        chart = price_curve * balance_integral * new_price
        return chart
    
    def view_points(self):
        current_price = (self.supply, self.price, 'Current Price')
        future_price = (self.supply+self.mint_amount, self.get_price(self.supply+self.mint_amount), 'Future Price')
        points = pd.DataFrame([future_price, current_price], columns=['x','y','label']).hvplot.scatter(
            x='x',
            y='y',
            by='label',
            color=['purple', 'orange'],
            size=80,) 
        return points
    
    @pm.depends('reserve_balance', 'supply', 'price', 'mint_amount')
    def view_chart(self):
        curve = self.view_price_over_supply_curve()
        points = self.view_points()
        chart = curve * points
        chart.opts(
            title="Bonding Curve Math",
            legend_position="top_right",
            xlim=self.param['supply'].softbounds,
            ylim=self.param['price'].softbounds,
            width=640,
            height=640,
        )
        return chart
    
    def view(self):
        return pn.Row(self, self.view_chart)
